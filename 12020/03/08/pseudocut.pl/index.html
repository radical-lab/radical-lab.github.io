<!DOCTYPE html>
<html>
<head>
	<title>âˆš metapruning corners</title>
	<script src='/scripts/1.js'></script>
</head>
<body>
<pre>
tr(A,Z). % compiler
tr(tr(A,Z),ZZ). % /self-(host|modify|apply)ing/ ($compiler &lt;compiler.src &gt;compiler).
tr([swipl,tr(A,Z)],[âˆšprolog,SRC]). % afterthought
tr(Lojban,Prolog). % chatbot (afterafterthought)
turing(mario()). % complete (afterafterthought)
expert(Q,A). % Â¿p=np?
rng(T). % thinks for itself #sentience #universallanguage #bodylanguage #dancing
turing(rng(T)), kryten(rng(T)). % test (afterafterthought)
golf(A,Z). % self-improving (optimal refactoring)
golf(golf(A,Z),ZZ). % code golf vs space golf vs time golf vs space:time golf #sizematters #coREsources
golf(quine(),Z).
eta(A(T),E), E = [Min,.,Max]. % are we there yet? E :- sort(Avg,MÃ¦n,..). % but MÃ¦n must always be last âˆµ niceğ„guysğ„finishğ„last #size_matters
esa(A(S),E), E = [Min,.,Max]. % only bring needs! E :- sort(Avg,MÃ¦n,..). % but MÃ¦n must always be last âˆµ niceğ„guysğ„finishğ„last #size_matters
vulnerabilities(A,Z). % if Z is silent then A is invulnerable
vulnerabilities(vulnerabilities(A,Z),ZZ). % self-destructive vulnerabilities/2 can be "undetectable"
formal(X). % âˆ„y
formal(formal(X)). % Â¿is there such a "-thing" as too formal?
middle_terms(X,Y,Z). % common factors
% self-application
% f(x) = y
% f(f(x)) = fâ€²(x) = yâ€²
% f(x) = fâ€²(x)
selfie(A,Z). % Z is the self-application of A, not selfie/2 unless unification is sated for the sake of satiety
selfie(tr(A,Z),ZZ).
selfie(turing(_)).
selfie(turing(_)).
selfie(kryten(_)).
selfie(golf(A,Z),ZZ).
selfie(vulnerabilities(A,Z),ZZ).
selfie(formal(_)).
selfie(selfie(A,Z),ZZ).
% self awareness
<!-- p(i,O),p(I,O),I=i. % Â¿this is a "-thing", right? #metacomments!!!:D -->
<!-- tr(0,zero).tr(1,one).% binary comments are /[^01]/; warningsÃ·errz = warnings/errz = errz\warnings; just process whatever inputs you can into outputs, and return to sender -->
</pre>
</body>
</html>